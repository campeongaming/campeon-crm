â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    CAMPEON CRM PROJECT - QUICK START GUIDE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROJECT STRUCTURE:
â”œâ”€â”€ src/                          (React/Next.js frontend code)
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â””â”€â”€ admin/bonus-browser/  (Bonus Browser page)
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ AdminPanel.tsx        (Pricing tables manager)
â”‚       â””â”€â”€ BonusBrowser.tsx      (Bonus search/browse)
â”œâ”€â”€ backend/                      (FastAPI backend)
â”‚   â”œâ”€â”€ main.py                   (FastAPI app entry point)
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ models.py             (Database models)
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ stable_config.py      (API endpoints)
â”‚   â”œâ”€â”€ casino_crm.db             (SQLite database)
â”‚   â””â”€â”€ .env                      (Environment config)
â””â”€â”€ package.json                  (Frontend dependencies)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            PREREQUISITES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Node.js installed (for frontend)
âœ“ Python 3.13+ installed (for backend)
âœ“ npm installed (comes with Node.js)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        TERMINAL SETUP (RECOMMENDED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Open TWO PowerShell terminals:
  - Terminal 1: For Frontend
  - Terminal 2: For Backend

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                         STEP 1: START FRONTEND
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TERMINAL 1 - FRONTEND:

cd "C:\Users\GiorgosKorifidis\Downloads\CAMPEON CRM PROJECT"

npm install
(Only needed first time or after package.json changes)

npm run dev

Expected Output:
  âœ“ Ready in XX.XXms
  â–² Next.js XX.X.X
  - Local:        http://localhost:3000
  - Environments: .env.local

Frontend will be available at: http://localhost:3000

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                         STEP 2: START BACKEND
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TERMINAL 2 - BACKEND:

cd "C:\Users\GiorgosKorifidis\Downloads\CAMPEON CRM PROJECT\backend"

C:\Users\GiorgosKorifidis\AppData\Local\Programs\Python\Python313\python.exe -m uvicorn main:app --reload --host 0.0.0.0 --port 8000

Expected Output:
  INFO:     Uvicorn running on http://0.0.0.0:8000
  INFO:     Application startup complete

Backend will be available at: http://localhost:8000

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      STEP 3: ACCESS THE APPLICATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Admin Panel (Pricing Tables):
  â†’ http://localhost:3000

Bonus Browser (Search/Browse):
  â†’ http://localhost:3000/admin/bonus-browser

API Documentation:
  â†’ http://localhost:8000/docs

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        FEATURES & ENDPOINTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FRONTEND FEATURES:

1. Admin Panel (http://localhost:3000)
   - Select Provider (PRAGMATIC / BETSOFT)
   - Manage pricing tables (Add/Remove)
   - Edit 21 currencies per table
   - Save/Load from database

2. Bonus Browser (http://localhost:3000/admin/bonus-browser)
   - Browse by Date (Year â†’ Month â†’ Day)
   - Search by Bonus ID
   - Translation Team: Fetch & Submit translations
   - CRM Ops Team: Create & Fetch bonus JSON

BACKEND ENDPOINTS:

Stable Config (Pricing Tables):
  POST   /api/stable-config              - Save config
  GET    /api/stable-config/{provider}   - Retrieve config
  GET    /api/stable-config              - List all configs

Bonus Templates:
  GET    /api/bonus-templates/months/{year}
  GET    /api/bonus-templates/dates/{year}/{month}
  GET    /api/bonus-templates/by-date/{year}/{month}/{day}
  GET    /api/bonus-templates/{id}
  GET    /api/bonus-templates/search?id={id}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        DATABASE INFORMATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Database Type: SQLite
Location: C:\Users\GiorgosKorifidis\Downloads\CAMPEON CRM PROJECT\backend\casino_crm.db

Tables:
  - stable_configs      (Provider pricing configurations)
  - bonus_templates     (Bonus data with timestamps)
  - bonus_translations  (Translation data by language)
  - currency_references (Currency mappings)

Environment Variable:
  DATABASE_URL=sqlite:///./casino_crm.db
  (Located in: backend/.env)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        TROUBLESHOOTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PORT ALREADY IN USE:

  Frontend (3000):
    taskkill /F /IM node.exe
    Then restart with: npm run dev

  Backend (8000):
    Get-Process -Name pythonw | Stop-Process -Force
    Or find by port: netstat -ano | findstr :8000
    Then restart backend

FRONTEND WON'T START:

  Delete node_modules:
    rm -r node_modules package-lock.json
    npm install
    npm run dev

BACKEND WON'T START:

  Install missing packages:
    C:\Users\GiorgosKorifidis\AppData\Local\Programs\Python\Python313\python.exe -m pip install uvicorn fastapi sqlalchemy pydantic python-dotenv

  Check .env file exists:
    backend/.env

DATABASE ERRORS:

  Reset database:
    Delete: backend/casino_crm.db
    Restart backend (will recreate database)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        QUICK REFERENCE COMMANDS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FRONTEND:
  Start:      npm run dev
  Build:      npm run build
  Stop:       Ctrl+C

BACKEND:
  CD:         cd "C:\Users\GiorgosKorifidis\Downloads\CAMPEON CRM PROJECT\backend"
  Start:      C:\Users\GiorgosKorifidis\AppData\Local\Programs\Python\Python313\python.exe -m uvicorn main:app --reload --host 0.0.0.0 --port 8000
  Stop:       Ctrl+C
  Test API:   Open http://localhost:8000/docs

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        DEVELOPMENT WORKFLOW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ALWAYS keep both terminals open and running
2. Frontend auto-reloads on file changes (npm run dev)
3. Backend auto-reloads on file changes (--reload flag)
4. Changes appear immediately without restart
5. Check browser console (F12) for frontend errors
6. Check backend terminal for API errors

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                     GIT - PUSH CHANGES TO REPOSITORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

To push your changes to Git:

STEP 1: Check what files changed
  git status

STEP 2: Stage all changes (or specific files)
  git add .
  (Or: git add <filename> for individual files)

STEP 3: Commit with a meaningful message
  git commit -m "Your message here"
  
  Example messages:
    git commit -m "feat: Add Bonus Browser UI with team actions"
    git commit -m "fix: Update database config to SQLite"
    git commit -m "feat: Add translation endpoints"
    git commit -m "docs: Update project documentation"

STEP 4: Push to remote repository
  git push origin main
  
  (Replace 'main' with your branch name if different)

STEP 5: Verify push was successful
  - Check GitHub/GitLab for new commits
  - Confirm all files appear in remote repository

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    COMMON GIT WORKFLOWS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

QUICK PUSH (All changes):
  git add .
  git commit -m "Update: [describe changes]"
  git push origin main

VIEW GIT LOG:
  git log --oneline -10    (Show last 10 commits)
  git log --graph --oneline --all (Show branch history)

UNDO LAST COMMIT (Before push):
  git reset HEAD~1         (Keep changes)
  git reset --hard HEAD~1  (Discard changes)

PULL LATEST CHANGES:
  git pull origin main

CHECK DIFFERENCES:
  git diff                 (Unstaged changes)
  git diff --staged        (Staged changes)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        CONTACT & HELP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

For issues:
  1. Check the terminal output (red errors)
  2. Check browser console (F12 â†’ Console tab)
  3. Check API documentation at http://localhost:8000/docs
  4. Verify both terminals are still running

GIT ISSUES:
  - "Permission denied" â†’ Check SSH key setup
  - "remote rejected" â†’ Ensure you have push access
  - "merge conflict" â†’ Manually resolve conflicts in files

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    READY TO GO! HAPPY CODING! ğŸš€
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                 FIX SUMMARY - Currency-Specific Values Bug
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATE FIXED: December 23, 2025
ERROR: TypeError - Cannot convert undefined or null to object
AFFECTED COMPONENTS: CasinoTeamForm.tsx, DepositBonusForm.tsx

PROBLEM DESCRIPTION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The system was crashing when trying to create bonuses because:

1. The form components were using incorrect Object.fromEntries() syntax
   - They were creating objects with generic '*' keys instead of currency-specific keys
   - Example WRONG: Object.fromEntries(CURRENCIES.map(() => ['*', value]))
   - Example RIGHT: Object.fromEntries(CURRENCIES.map(c => [c, value]))

2. The pricing table fetch logic was incorrect
   - Admin API returns maximum_withdraw as an ARRAY of tables, not a single object
   - Code was trying to access .values directly instead of from the first array element
   - Example WRONG: response.data.maximum_withdraw.values
   - Example RIGHT: response.data.maximum_withdraw[0].values

3. The form tried to use Object.entries() on potentially undefined objects
   - When maximumWithdraw was undefined/null, it crashed
   - No null coalescing or safety checks were in place

COMPLETE FIX - What Was Changed:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILE 1: src/components/CasinoTeamForm.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ Added imports: useEffect, and moved useState to include it
âœ“ Added interface CurrencyTable for type safety
âœ“ Added interface StableConfig to represent admin pricing tables
âœ“ Added state management:
  - selectedProvider: tracks which provider's pricing to fetch
  - pricingTable: stores fetched admin pricing table
  - loadingPricing: loading state for async fetch

âœ“ Fixed Object.fromEntries() calls in initial state:
  Line 69-72: Changed from ['*', value] to [c, value] for all currency fields
  - minimum_amount: Object.fromEntries(CURRENCIES.map(c => [c, 25]))
  - maximum_amount: Object.fromEntries(CURRENCIES.map(c => [c, 300]))
  - minimum_stake_to_wager: Object.fromEntries(CURRENCIES.map(c => [c, 0.5]))
  - maximum_stake_to_wager: Object.fromEntries(CURRENCIES.map(c => [c, 5]))
  - maximum_withdraw: Object.fromEntries(CURRENCIES.map(c => [c, 3]))

âœ“ Added useEffect hook to fetch pricing table on component mount:
  - Calls GET /api/stable-config/{selectedProvider}
  - Handles the array response format correctly:
    if (response.data?.maximum_withdraw && Array.isArray(response.data.maximum_withdraw)) {
        const withdrawTable = response.data.maximum_withdraw[0];
        if (withdrawTable?.values) { ... }
    }
  - Auto-populates maximum_withdraw field with fetched values
  - Falls back to defaults if fetch fails

âœ“ Updated handleBasicChange to trigger fetch when provider changes:
  if (name === 'provider') {
      setSelectedProvider(value);
  }

âœ“ Updated form UI:
  - Added provider selector at top of form
  - Added loading indicator when fetching pricing
  - Added visual note: "Maximum withdraw amounts auto-populated from admin pricing table"
  - Highlighted maximum_withdraw column in amber/yellow to show it's from admin setup
  - Added note at bottom: "* Values auto-populated from {provider} Withdrawals table in Admin Panel"

FILE 2: src/components/DepositBonusForm.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ Fixed useEffect hook (lines 65-90):
  - Added Array.isArray() checks before using array methods
  - Properly extract first table from array: response.data.maximum_withdraw[0]
  - Only access .values from the extracted table object
  - Added error handling that keeps defaults if fetch fails

  BEFORE:
    if (response.data?.maximum_withdraw?.values) {
        setAdminMaxWithdraw(response.data.maximum_withdraw.values);
    }

  AFTER:
    if (response.data?.maximum_withdraw && Array.isArray(response.data.maximum_withdraw)) {
        const withdrawTable = response.data.maximum_withdraw[0];
        if (withdrawTable?.values) {
            setAdminMaxWithdraw(withdrawTable.values);
        }
    }

âœ“ Fixed Object.entries() crash (line 205):
  - Added null coalescing operator to prevent crash
  - Object.entries(formData.maximumWithdraw || {})
  
  This ensures even if maximumWithdraw is undefined, we create empty object
  and Object.entries() won't crash

âœ“ Fixed form reset (line 247):
  - Changed from hardcoded default to use fetched adminMaxWithdraw
  - maximumWithdraw: adminMaxWithdraw || Object.fromEntries(CURRENCIES.map(c => [c, 100]))

HOW IT WORKS NOW - Complete Flow:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. USER SELECTS PROVIDER (PRAGMATIC / BETSOFT)
   â†“
2. COMPONENT TRIGGERS useEffect HOOK
   â†“
3. FETCH FROM /api/stable-config/{provider}
   â†“
4. EXTRACT FIRST TABLE FROM ARRAY: response.data.maximum_withdraw[0]
   â†“
5. GET .values FROM TABLE: withdrawTable.values = { EUR: 3, USD: 2.5, ... }
   â†“
6. AUTO-POPULATE FORM FIELDS with currency-specific values
   â†“
7. USER CREATES BONUS
   â†“
8. FORM DATA HAS PROPER CURRENCY KEYS (not '*' keys)
   â†“
9. Object.entries() safely converts to: [[EUR, 3], [USD, 2.5], ...]
   â†“
10. SUBMIT SUCCEEDS âœ…

TESTING CHECKLIST:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Go to Admin Panel â†’ Set up pricing tables with PRAGMATIC provider
  - Create withdrawal table with values for at least EUR, USD, GBP
  - Save the table to database

âœ“ Go to CasinoTeamForm
  - Provider should default to PRAGMATIC
  - Select different providers to see auto-fetch work
  - Maximum withdraw column should show values from admin setup

âœ“ Go to DepositBonusForm
  - Should auto-load admin pricing values
  - Can enter EUR cost and see free spins
  - Submit should work without errors

KEY TAKEAWAY FOR NEXT CHAT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The system now properly:
1. Fetches pricing tables from admin setup via API
2. Extracts currency-specific values from table arrays
3. Uses correct Object.fromEntries() syntax with currency keys (not '*')
4. Safely handles undefined/null values with coalescing
5. Auto-populates bonus forms with pricing from admin configuration
6. No more "Cannot convert undefined or null to object" errors

All forms now correctly fetch the withdrawals table and use those values
for each currency when creating bonuses.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              UI CLEANUP - Removed Bonus Creation from Browse Tab
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATE CLEANED: December 23, 2025
COMPONENT: src/components/BonusBrowser.tsx

WHAT WAS REMOVED:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Removed BonusWizard import
âœ“ Removed showWizard state management
âœ“ Removed handleBonusCreated function
âœ“ Removed wizard conditional render (if showWizard { return <BonusWizard/> })
âœ“ Removed "âœ¨ Create New Bonus" button from header

WHY THIS WAS DONE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The Browse Bonuses tab should ONLY display:
  - Browse bonuses by date
  - Search bonuses by ID
  - Translation Team actions
  - CRM Ops Team actions

The creation logic will be moved to a dedicated "Create Bonus" tab that supports
multiple bonus types (not just Deposit).

WHAT REMAINS - For Future Implementation:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The BonusItem interface still includes:
  - category: string              (will be used for DEPOSIT, RELOAD, FSDROP, etc.)
  - trigger_type: string          (will categorize bonus types)

These fields are preserved so when you build the "Create Bonus" tab, you can:
  1. Create bonuses with different categories (DEPOSIT, RELOAD, WAGER, COMBO, etc.)
  2. Use trigger_type to categorize how bonuses are triggered
  3. Implement category-specific form fields

BONUS CATEGORIES TO IMPLEMENT LATER:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

From bonusConfig.ts, these 7 types should each have their own creation form:

1. DEPOSIT   - "Deposit up to â‚¬300"
2. RELOAD    - "Reload 200% bonus"
3. FSDROP    - "Drop 50 Free Spins"
4. WAGER     - "200â‚¬ and get 500 free spins"
5. SEQ       - "Sequential multi-stage bonus"
6. COMBO     - "Combine multiple bonuses"
7. CASHBACK  - "10% Cashback"

NEXT STEPS:
â•â•â•â•â•â•â•â•â•â•â•â•

When ready, create a new "Create Bonus" tab that:
1. Allows selection of bonus type (from the 7 categories above)
2. Shows type-specific form fields
3. Handles multi-currency pricing from admin setup
4. Submits to appropriate API endpoint

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You are helping me build a â€œBonus JSON Generatorâ€ app.

GOAL
A user selects a BONUS TYPE, fills a small set of required inputs, and the app generates the correct JSON config in the correct format for that bonus type. The generator must be template-driven and schema-aware, based on patterns found across multiple bonus JSON files.

BIG PICTURE (FIRST THINGS FIRST)
All bonus JSONs belong to the same overall â€œfamilyâ€ with a shared top-level skeleton. The generator must:
1. Identify the â€œfamily skeletonâ€ (fields always present),
2. Identify â€œformat branchesâ€ (fields that differ based on trigger type and reward type),
3. Enforce required fields + optional fields per branch,
4. Fill defaults consistently (currency â€œ*â€ fallbacks, expiry/duration defaults, etc.),
5. Output valid JSON that matches the exact structure expected by our system.

TOP-LEVEL JSON SKELETON (ALMOST ALWAYS PRESENT)
The generated JSON should follow this structure:
{
  "id": string,                    // required: human-readable unique promo id/title
  "trigger": { ... },              // required: qualification logic (varies by type)
  "config": { ... },               // required: reward mechanics (varies by type)
  "type": "bonus_template"         // usually required: discriminator
  // "schedule": { ... }            // optional: time-windowed promos only
}

KEY CONCEPTS / MAIN â€œSWITCHESâ€
The JSON format is determined primarily by:
A. trigger.type  (deposit | external | open | manual)
B. config.type   (cash | free_bet | cashback-like if present)
C. config.category (games | live_casino | sports_book)
D. optional top-level schedule (period window)

Therefore: implement the generator as a set of templates keyed by:
bonusFamily = (trigger.type, config.type, config.category, schedulePresent?)

BRANCH 1: DEPOSIT-TRIGGERED CASH RELOAD (classic reload/package)
trigger:
- required: type="deposit"
- required: duration (e.g., "7d")
- required: minimumAmount (number or per-currency map, depending on your system)
- often required: iterations, minimumDepositCount, segments (Fast Track segment IDs)
- optional: allowedCountries / restrictedCountries
config:
- required: type="cash"
- required: category="games" OR "live_casino"
- required: percentage, wageringMultiplier
- required: maximumAmount (per currency or single number depending on rules)
- required: minimumStakeToWager, maximumStakeToWager
- required: includeAmountOnTargetWagerCalculation, capCalculationAmountToMaximumBonus, compensateOverspending
- usually: withdrawActive=false
- required/typical: provider="SYSTEM", brand="SYSTEM"
- optional but common: extra.proportions (large mapping of game/category weights)

Optional top-level:
- schedule: include when promo is time-boxed (schedule.type="period", from/to timestamps, optional timezone)

BRANCH 2: EXTERNAL-TRIGGERED FREE SPINS / FREE BET (drops, wager missions, etc.)
trigger:
- required: type="external"
- required: duration (e.g., "1d", "7d")
- required: name (translation map with "*" default and localized keys like "GBP_en", "EUR_pt", etc.)
- optional: description
- optional: minimumLossAmount (common in cashback-like external triggers)
Optional top-level:
- schedule present if itâ€™s a limited-time campaign (period from/to)

config:
- required: type="free_bet" (used for â€œfree spins/free bet styleâ€ rewards)
- required: category: "games" (most cases) or "sports_book" (sports freebet)
- required: provider + brand (e.g., PRAGMATIC for casino, ALTENAR_V2 for sportsbook)
- required: cost (currency map, often includes "*" fallback)
- required: multiplier (currency map)
- required: maximumBets (currency map)
- required: expiry (e.g., "2d", "7d")
- required: maximumWithdraw (either cap-only or {cap, multiplier} per currency)
- usually: withdrawActive=false
- config.extra differs by subtype:
  - for casino FS: extra.game = "Game Name"
  - for sportsbook freebet: extra.planId = "..."
So: choose extra.* fields based on category/provider subtype.

BRANCH 3: OPEN-TRIGGERED CHAINED BONUS (combo step 2 depends on step 1)
trigger:
- required: type="open"
- required: ids: [string, ...]  // references another promoâ€™s id(s)
- required: duration
- optional: minimumAmount (currency map)
- required: name translation map (can be "*" only OR full localized set)
config:
- usually type="free_bet" (often FS as step 2)
- same required fields as Branch 2 (cost/multiplier/maximumBets/expiry/maximumWithdraw/provider/brand/category)
- extra.game or extra.planId same rules as above

BRANCH 4: MANUAL TRIGGERED (if used)
trigger:
- required: type="manual"
- required: duration and/or name (depending on existing patterns)
config:
- depends on whether reward is cash or free_bet; reuse Branch 1 or 2 config schemas accordingly.

BRANCH 5: CASHBACK (distinct family; may not be bonus_template)
Some cashback JSONs differ: may include created_at/updated_at and have:
config: percentage, maximumCashback, withdrawActive=true, restrictedCountries, etc.
Implement this as a separate template family if needed (and donâ€™t force "type":"bonus_template" if the existing examples donâ€™t have it).

CURRENCY & LOCALIZATION RULES (IMPORTANT)
- Many numeric fields are per-currency maps (EUR, USD, GBP, NOK, etc.) and sometimes "*" as default.
- trigger.name is a localization map:
  - always include "*" as fallback
  - include the locales we support (en, de, fi, no, it, fr, es, pt, plus currency-language variants like GBP_en, EUR_pt, etc.) depending on bonus type preset.
- Ensure currency sets may vary by promo; generator should allow selecting â€œcurrency set presetsâ€ (EU set, full global set) instead of hardcoding one.

IMPLEMENTATION REQUIREMENTS
1. Create a â€œBonusTypeâ€ selection UI (dropdown) mapped to the template branches above.
2. For each BonusType, define:
   - Required inputs (minimal form)
   - Optional inputs (advanced)
   - Defaults (duration, expiry, withdrawActive, provider/brand if fixed)
3. Build a template engine:
   - Start with skeleton
   - Merge trigger template + config template
   - Conditionally attach schedule if selected
   - Validate required fields before JSON output
4. Output pretty-printed JSON with stable key ordering.

REQUIRED USER INPUTS (MINIMUM FOR EACH TYPE)
- Always: id
- If schedule is enabled: from, to, timezone optional
- Trigger fields based on trigger.type (deposit/external/open/manual)
- Config fields based on config.type and category:
  - cash: percentage, max amount, wageringMultiplier, min/max stake, segments (if required)
  - free_bet: provider, brand, category, cost/multiplier/maximumBets/expiry/maximumWithdraw, extra.game or extra.planId

DELIVERABLE
Implement the generator with:
- A set of TypeScript interfaces/types for the schemas
- A template map (object) from BonusType -> template builder function
- Runtime validation (zod or custom) per BonusType
- A single function `generateBonusJson(formState): BonusJson` that returns the final JSON.

Start by implementing the schema/types and the template builder functions first, then wire the UI form to those builders.
